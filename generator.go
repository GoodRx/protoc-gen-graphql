package main

import (
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/golang/protobuf/protoc-gen-go/generator"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"

	"github.com/martinxsliu/protoc-gen-graphql/graphqlpb"
)

const header = `# DO NOT EDIT! Generated by protoc-gen-graphql.`

type Generator struct {
	req    *plugin.CodeGeneratorRequest
	resp   *plugin.CodeGeneratorResponse
	params *Parameters

	files    map[string]*FileDescriptor
	messages map[string]*MessageDescriptor
	enums    map[string]*EnumDescriptor

	emptyMessages map[string]bool

	// Maps qualified protobuf types to graphql types.
	// e.g. google.protobuf.StringValue -> GoogleProtobuf_StringValue
	typeNameMap  map[string]string
	inputNameMap map[string]string
}

func New(req *plugin.CodeGeneratorRequest, resp *plugin.CodeGeneratorResponse) (*Generator, error) {
	params, err := NewParameters(req.GetParameter())
	if err != nil {
		return nil, err
	}

	return &Generator{
		req:    req,
		resp:   resp,
		params: params,
	}, nil
}

func (g *Generator) Generate() error {
	g.wrapFiles()
	g.generateFiles()
	return nil
}

func (g *Generator) wrapFiles() {
	g.files = make(map[string]*FileDescriptor)
	for _, fileProto := range g.req.GetProtoFile() {
		g.files[fileProto.GetName()] = wrapFile(fileProto)
	}
	g.buildTypeMaps()
}

func (g *Generator) buildTypeMaps() {
	g.messages = make(map[string]*MessageDescriptor)
	g.enums = make(map[string]*EnumDescriptor)
	g.emptyMessages = make(map[string]bool)
	g.typeNameMap = make(map[string]string)
	g.inputNameMap = make(map[string]string)

	// Ensure that we're iterating in topological order.
	for _, fileDescriptor := range g.req.GetProtoFile() {
		file := g.files[fileDescriptor.GetName()]

		for _, message := range file.Messages {
			g.messages[message.FullName] = message
		}
		for _, enum := range file.Enums {
			g.enums[enum.FullName] = enum
		}

		if !g.params.ServiceTypesOnly {
			// Build the message and enum map for the file first, before building the
			// proto to graphql name maps.
			for _, message := range file.Messages {
				g.buildTypesFromMessage(message, false)
			}
			for _, enum := range file.Enums {
				g.buildTypesFromEnum(enum)
			}
		}

		for _, service := range file.Services {
			g.typeNameMap[service.FullName] = buildGraphqlTypeName(&graphqlTypeNameParts{
				Package:  file.Proto.GetPackage(),
				TypeName: service.TypeName,
			})

			for _, method := range service.Proto.GetMethod() {
				if g.params.ServiceTypesOnly {
					g.buildTypesFromMessage(g.messages[method.GetOutputType()], false)
				}
				g.buildTypesFromMessage(g.messages[method.GetInputType()], true)
			}
		}
	}
}

func (g *Generator) buildTypesFromMessage(message *MessageDescriptor, input bool) {
	nameMap := g.typeNameMap
	if input {
		nameMap = g.inputNameMap
	}

	if nameMap[message.FullName] != "" {
		return
	}
	if len(message.Proto.GetField()) == 0 {
		g.emptyMessages[message.FullName] = true
		return
	}

	nameMap[message.FullName] = buildGraphqlTypeName(&graphqlTypeNameParts{
		Package:    message.Package,
		TypeName:   message.TypeName,
		Input:      input,
		IsProtoMap: message.IsMap,
	})

	for _, field := range message.Proto.GetField() {
		if field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			g.buildTypesFromMessage(g.messages[field.GetTypeName()], input)
		}

		if field.GetType() == descriptor.FieldDescriptorProto_TYPE_ENUM {
			g.buildTypesFromEnum(g.enums[field.GetTypeName()])
		}
	}
}

func (g *Generator) buildTypesFromEnum(enum *EnumDescriptor) {
	g.typeNameMap[enum.FullName] = buildGraphqlTypeName(&graphqlTypeNameParts{
		Package:  enum.Package,
		TypeName: enum.TypeName,
	})
}

func (g *Generator) generateFiles() {
	for _, fileName := range g.req.GetFileToGenerate() {
		fileResp := &plugin.CodeGeneratorResponse_File{}
		fileResp.Name = stringPtr(graphqlFileName(fileName))

		file := g.files[fileName]

		var graphqlTypes []GraphqlType

		for _, service := range file.Services {
			for _, graphql := range g.graphqlFromService(service) {
				graphqlTypes = append(graphqlTypes, graphql)
			}
		}

		for _, message := range file.Messages {
			for _, graphql := range g.graphqlFromMessage(message) {
				graphqlTypes = append(graphqlTypes, graphql)
			}
		}

		for _, enum := range file.Enums {
			for _, graphql := range g.graphqlFromEnum(enum) {
				graphqlTypes = append(graphqlTypes, graphql)
			}
		}

		// Don't generate files without any type declarations.
		if len(graphqlTypes) == 0 {
			continue
		}

		var b strings.Builder
		b.WriteString(header)
		b.WriteString("\n\n")
		for i, graphql := range graphqlTypes {
			b.WriteString(graphql.ToGQL())
			if i != len(graphqlTypes)-1 {
				b.WriteString("\n\n")
			}
		}
		b.WriteString("\n")
		fileResp.Content = stringPtr(b.String())

		g.resp.File = append(g.resp.File, fileResp)
	}
}

func (g *Generator) graphqlFromMessage(message *MessageDescriptor) []GraphqlType {
	var graphqlTypes []GraphqlType

	if typeName, ok := g.typeNameMap[message.FullName]; ok {
		graphqlTypes = append(graphqlTypes, &GraphqlObject{
			Name:   typeName,
			Fields: g.graphqlFields(message, false),
		})

		for i := 0; i < len(message.Proto.GetOneofDecl()); i++ {
			graphqlTypes = append(graphqlTypes, g.graphqlUnionFromOneof(message, int32(i))...)
		}
	}

	if inputName, ok := g.inputNameMap[message.FullName]; ok {
		graphqlTypes = append(graphqlTypes, &GraphqlInput{
			Name:   inputName,
			Fields: g.graphqlFields(message, true),
		})

		for i := 0; i < len(message.Proto.GetOneofDecl()); i++ {
			graphqlTypes = append(graphqlTypes, g.graphqlInputFromOneof(message, int32(i)))
		}
	}

	return graphqlTypes
}

func (g *Generator) graphqlFields(message *MessageDescriptor, input bool) []*GraphqlField {
	var fields []*GraphqlField

	seenOneofs := make(map[int32]bool)
	for _, fieldProto := range message.Proto.GetField() {
		// if g.emptyMessages[fieldProto.GetTypeName()] {
		// 	continue
		// }

		if fieldProto.OneofIndex == nil {
			fields = append(fields, g.graphqlField(fieldProto, fieldOptions{Input: input}))
			continue
		}

		index := *fieldProto.OneofIndex
		if seenOneofs[index] {
			continue
		}

		oneof := message.Proto.GetOneofDecl()[index].GetName()
		fields = append(fields, &GraphqlField{
			Name: oneof,
			Type: GraphqlTypeClassObject,
			TypeName: buildGraphqlTypeName(&graphqlTypeNameParts{
				Package:  message.Package,
				TypeName: append(message.TypeName, oneof),
				Input:    input,
			}),
		})

		seenOneofs[index] = true
	}

	return fields
}

type fieldOptions struct {
	Input           bool
	NullableScalars bool
}

func (g *Generator) graphqlField(proto *descriptor.FieldDescriptorProto, options fieldOptions) *GraphqlField {
	field := &GraphqlField{
		Name: proto.GetName(),
	}

	switch proto.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_FLOAT, descriptor.FieldDescriptorProto_TYPE_DOUBLE,
		descriptor.FieldDescriptorProto_TYPE_UINT32, descriptor.FieldDescriptorProto_TYPE_SINT32,
		descriptor.FieldDescriptorProto_TYPE_FIXED32, descriptor.FieldDescriptorProto_TYPE_SFIXED32:

		field.Type = GraphqlTypeClassFloat
		field.Modifiers = GraphqlTypeModifierNonNull
	case descriptor.FieldDescriptorProto_TYPE_STRING, descriptor.FieldDescriptorProto_TYPE_BYTES,
		descriptor.FieldDescriptorProto_TYPE_INT64, descriptor.FieldDescriptorProto_TYPE_UINT64, descriptor.FieldDescriptorProto_TYPE_SINT64,
		descriptor.FieldDescriptorProto_TYPE_FIXED64, descriptor.FieldDescriptorProto_TYPE_SFIXED64:

		field.Type = GraphqlTypeClassString
		if !options.NullableScalars {
			field.Modifiers = GraphqlTypeModifierNonNull
		}
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		field.Type = GraphqlTypeClassInt
		if !options.NullableScalars {
			field.Modifiers = GraphqlTypeModifierNonNull
		}
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		field.Type = GraphqlTypeClassBoolean
		if !options.NullableScalars {
			field.Modifiers = GraphqlTypeModifierNonNull
		}
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		field.Type = GraphqlTypeClassEnum
		field.TypeName = g.typeNameMap[proto.GetTypeName()]
		if !options.NullableScalars {
			field.Modifiers = GraphqlTypeModifierNonNull
		}
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		if g.emptyMessages[proto.GetTypeName()] {
			field.Type = GraphqlTypeClassBoolean
		} else {
			field.Type = GraphqlTypeClassObject
			if options.Input {
				field.TypeName = g.inputNameMap[proto.GetTypeName()]
			} else {
				field.TypeName = g.typeNameMap[proto.GetTypeName()]
			}

			// Map elements are non-nullable.
			if g.messages[proto.GetTypeName()].IsMap {
				field.Modifiers = GraphqlTypeModifierNonNull
			}
		}
	}

	if proto.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
		field.Modifiers = field.Modifiers | GraphqlTypeModifierList
	}

	return g.graphqlSpecialTypes(field, proto.GetTypeName())
}

func (g *Generator) graphqlSpecialTypes(field *GraphqlField, protoTypeName string) *GraphqlField {
	if protoTypeName == ".google.protobuf.Timestamp" && g.params.TimestampTypeName != "" {
		field.TypeName = g.params.TimestampTypeName
	}
	if protoTypeName == ".google.protobuf.Duration" && g.params.DurationTypeName != "" {
		field.TypeName = g.params.DurationTypeName
	}

	if g.params.WrappersAsNull {
		switch protoTypeName {
		case ".google.protobuf.FloatValue", ".google.protobuf.DoubleValue", ".google.protobuf.UInt32Value":
			field.Type = GraphqlTypeClassFloat
			field.TypeName = ""
		case ".google.protobuf.StringValue", ".google.protobuf.BytesValue", ".google.protobuf.Int64Value", ".google.protobuf.UInt64Value":
			field.Type = GraphqlTypeClassString
			field.TypeName = ""
		case ".google.protobuf.Int32Value":
			field.Type = GraphqlTypeClassInt
			field.TypeName = ""
		case ".google.protobuf.BoolValue":
			field.Type = GraphqlTypeClassBoolean
			field.TypeName = ""
		}
	}

	return field
}

func (g *Generator) graphqlUnionFromOneof(message *MessageDescriptor, oneofIndex int32) []GraphqlType {
	oneof := message.Proto.GetOneofDecl()[oneofIndex].GetName()
	union := &GraphqlUnion{
		Name: buildGraphqlTypeName(&graphqlTypeNameParts{
			Package:  message.Package,
			TypeName: append(message.TypeName, oneof),
		}),
	}
	graphqlTypes := []GraphqlType{union}

	for _, fieldProto := range message.Proto.GetField() {
		if fieldProto.OneofIndex == nil || *fieldProto.OneofIndex != oneofIndex {
			continue
		}

		typeName := buildGraphqlTypeName(&graphqlTypeNameParts{
			Package:  message.Package,
			TypeName: append(message.TypeName, oneof, fieldProto.GetName()),
		})

		union.TypeNames = append(union.TypeNames, typeName)
		graphqlTypes = append(graphqlTypes, &GraphqlObject{
			Name:   typeName,
			Fields: []*GraphqlField{g.graphqlField(fieldProto, fieldOptions{})},
		})
	}

	return graphqlTypes
}

func (g *Generator) graphqlInputFromOneof(message *MessageDescriptor, oneofIndex int32) GraphqlType {
	oneof := message.Proto.GetOneofDecl()[oneofIndex].GetName()

	var fields []*GraphqlField
	for _, fieldProto := range message.Proto.GetField() {
		if fieldProto.OneofIndex == nil || *fieldProto.OneofIndex != oneofIndex {
			continue
		}
		fields = append(fields, g.graphqlField(fieldProto, fieldOptions{Input: true, NullableScalars: true}))
	}

	return &GraphqlInput{
		Name: buildGraphqlTypeName(&graphqlTypeNameParts{
			Package:  message.Package,
			TypeName: append(message.TypeName, oneof),
			Input:    true,
		}),
		Fields: fields,
	}
}

func (g *Generator) graphqlFromEnum(enum *EnumDescriptor) []GraphqlType {
	var graphqlTypes []GraphqlType

	if g.typeNameMap[enum.FullName] == "" {
		return graphqlTypes
	}

	var values []string
	for _, protoValue := range enum.Proto.GetValue() {
		values = append(values, protoValue.GetName())
	}

	graphqlTypes = append(graphqlTypes, &GraphqlEnum{
		Name:   g.typeNameMap[enum.FullName],
		Values: values,
	})

	return graphqlTypes
}

func (g *Generator) graphqlFromService(service *ServiceDescriptor) []GraphqlType {
	var (
		graphqlTypes  []GraphqlType
		queries       []*GraphqlField
		mutations     []*GraphqlField
		subscriptions []*GraphqlField
	)

	for _, method := range service.Proto.GetMethod() {
		var operation string
		if proto.HasExtension(method.GetOptions(), graphqlpb.E_Operation) {
			extVal, err := proto.GetExtension(method.GetOptions(), graphqlpb.E_Operation)
			if err != nil {
				panic(err)
			}
			operation = *extVal.(*string)
		}

		if operation == "none" {
			return nil
		}

		field := g.graphqlFieldFromMethod(method)

		switch operation {
		case "mutation":
			mutations = append(mutations, field)
		case "subscription":
			subscriptions = append(subscriptions, field)
		default:
			queries = append(queries, field)
		}
	}

	if len(queries) > 0 {
		graphqlTypes = append(graphqlTypes, &GraphqlObject{
			Name:   g.typeNameMap[service.FullName] + "_Query",
			Fields: queries,
		})
	}
	if len(mutations) > 0 {
		graphqlTypes = append(graphqlTypes, &GraphqlObject{
			Name:   g.typeNameMap[service.FullName] + "_Mutation",
			Fields: mutations,
		})
	}
	if len(subscriptions) > 0 {
		graphqlTypes = append(graphqlTypes, &GraphqlObject{
			Name:   g.typeNameMap[service.FullName] + "_Subscription",
			Fields: subscriptions,
		})
	}

	return graphqlTypes
}

func (g *Generator) graphqlFieldFromMethod(method *descriptor.MethodDescriptorProto) *GraphqlField {
	// Only add an argument if there are fields in the gRPC request message.
	var arguments []*GraphqlArgument
	inputType := g.messages[method.GetInputType()]
	if len(inputType.Proto.GetField()) != 0 {
		arguments = append(arguments, &GraphqlArgument{
			Name:      "input",
			Type:      GraphqlTypeClassInput,
			TypeName:  g.inputNameMap[method.GetInputType()],
			Modifiers: GraphqlTypeModifierNonNull,
		})
	}

	// If the response message has no fields then return a nullable Boolean.
	// It is up to the resolver's implementation whether or not to return an
	// actual boolean value or default to null.
	outputType := g.messages[method.GetOutputType()]
	if len(outputType.Proto.GetField()) == 0 {
		return &GraphqlField{
			Name:      method.GetName(),
			Type:      GraphqlTypeClassBoolean,
			Arguments: arguments,
		}
	}

	return &GraphqlField{
		Name:      method.GetName(),
		Type:      GraphqlTypeClassObject,
		TypeName:  g.typeNameMap[method.GetOutputType()],
		Arguments: arguments,
		Modifiers: GraphqlTypeModifierNonNull,
	}
}

type graphqlTypeNameParts struct {
	Package    string
	TypeName   []string
	IsProtoMap bool
	Input      bool
}

func buildGraphqlTypeName(parts *graphqlTypeNameParts) string {
	var b strings.Builder
	b.WriteString(generator.CamelCaseSlice(strings.Split(parts.Package, ".")))
	for i, name := range parts.TypeName {
		if parts.IsProtoMap && i == len(parts.TypeName)-1 {
			name = strings.TrimSuffix(name, "Entry")
		}

		b.WriteString("_")
		b.WriteString(generator.CamelCase(name))
	}
	if parts.Input {
		b.WriteString("_Input")
	}
	return b.String()
}

func graphqlFileName(name string) string {
	return strings.TrimSuffix(name, ".proto") + "_pb.graphql"
}

func stringPtr(v string) *string {
	return &v
}
